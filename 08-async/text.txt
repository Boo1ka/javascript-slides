[v] 1. Синхронный код. Стек вызовов. Очередь событий [1.1 - 4.10] (10-12 минут)
[v] 2. Системные таймеры: setTimeout, setInterval, clearInterval [5.1 - 6-13] (8-10 минут)
[v] 3. Особенности работы системных таймеров. Нулевой интервал [7.1 - 8.6] (7-9 минут)
[ ] 4. Работа с файлами: синхронное и асинхронное чтение [9.1 - 9.8] (8-10 минут)
[ ] 5. Использование колбеков для работы с асинхронностью [10.1 - 10.15] (10-12 минут)
[ ] 6. Промисы. Создание. Использование. Достоинства и недостатки [11.1 - 11.18] (8-10 минут)
[ ] 7. Цепочки промисов. Параллельность в промисах [12.1 - 13.4] (7-9 минут)

1. Привет. На этой неделе я расскажу вам о том что такое асинхронный код и как
с ним работать в языке JavaScript.

2. Почти весь код, который мы рассматривали до этой лекции был синхронным,
а значит мы всегда могли однозначно понять какая функция сейчас выполняется.
Например, если мы объявим несколько функций который помогут нам приготовить
кофе и станем вызывать их одну за другой, то мы получим результат в том порядке
в котором вызывали функции, шаг за шагом.

С асинхронным кодом все немного сложнее. Для того чтобы понять как устроена
асинхронность в JavaScript'е давайте рассмотрим следующие две темы: стек вызовов
и очередь событий.

Стек вызовов это структура данных которую использует интерпретатор. Перед тем как
начать выполнять наш код он помещает в стек анонимную функцию,
которая содержит код программы. Вызывая эту функцию интерпретатор выполняет код,
когда весь код отработает функция завершится, то анонимная функция будет
вытолкнута из стека и наша программа завершит свою работу.

Если на выполняемом участке кода встречается вызов функции то она помещается на
вершину стека, а интерпретатор начинает работать с ней. В нашем случае при работ

9.1 Ещё один способ записать функцию в очередь событий - это выполнить некоторую
асинхронную операцию после выполнения которой будет вызван обработчик. В качестве
таких операций могут выступать операции работы с файлами. Давайте рассмотрим их
подробнее

Для того чтобы поработать с файловой системой мы подключим встроенный модуль fs
при помощи функции require. Для того чтобы прочитать файл, который находится в
той же директории что и файл с нашим кодом мы можем воспользоваться переменной
__dirname в которой находится абсолютный путь для директории с нашим кодом.

Далее мя производим чтение файла при помощи метода readFileSync бибилиотеки fs
Первым аргументом функция принимет путь до нужного файла, вторым - кодировку в
которой нужно проситать файл. Если не указать кодировку то функция вернет буфер
вместо строки. По завершению чтения мы выведем содердимо файла на консоль.

В данном случае мы воспользовались синхронным методом чтения файла, на это указывает
суффикс sync. И если мы имеем дело с небольшими файлами такой способ чтения допустим.
Чтобы определить как долго проиходит операция чтения мы воспользуемся методом time
и свойства console. Для того чтобы запустить замер времени мы вызовем метод time
со с произвольной строкой - идентификатором, например readFileSync. Для
остановки замера вызовем парную функцию timeEnd с таким же идентификатором.

В результате мы увидим на консоли время, в течение которого наш код простаивал.
В данном слуае это три секуды, наверное это не очень много. Однако, если взять
файл по-больше то это время увеличиваетс в разы. Например для большого файла bigData.mov
это время составит аж целых три с половиной секунды. А это значит что всё это время
наш сервер простаивал, не обрабатывал запросы пользователей и не делал никакой
другой полезной работы.

...

В этом видео мы подробнее разберем как устроены колбеки, перечислим сильные и
слабые стороны этого способа работы с асинхронным кодом. Разберем
когда следует применять этот подход.

Коллбек, или функция обратного вызова в nodejs имеет следующую сигнатуру:
первый аргумент коллбека это ошибка которая произошла во время выполнения асинхронной
операции. Если операция выполнилась без ошибки, то в качестве первого аргумента в функцию
принято передавать null. Вторым аргументов в коллбек передаются данные, которые были
получены во время выполнения асинхронной операции. Например, в случае чтения
файла во втором аргументе будет находиться содержимое файла.

Используя коллбеки мы не несем никаких дополнительных накладных расходов,
это быстрый способ обработать результат асинхронной операции. Помимо этого для
использования коллбеков нам не понадобится никаких дополнительных библиотек.

Однако, используя коллбеки мы получаем следующий набор недостатков.
Во-первых, при усложнении асинхронного кода реализованного на коллбеках
растет уровень вложенности. В данном примере обработчик данных - вывод на
консоль находится на втором уровне вложенности, однако как только мы заходим
прочитать два файла последовательно, то обработчик положительного результата
будет аж на четвертом уровне. И чем сложнее ваш код тем глубже и запутаннее
становится код.

Во-вторых обработка ошибки и данных, разных по своей природе исходов, приходится
производить в одном месте что конечно же усложняет код
